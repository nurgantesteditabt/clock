
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Burning Candle Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.8rem; margin-top: 5px; }
        #reset-btn {
            pointer-events: auto;
            margin-top: 10px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.3s;
        }
        #reset-btn:hover { background: rgba(255, 255, 255, 0.3); }
    </style>
</head>
<body>

<div id="ui">
    <h1>Candle Simulation</h1>
    <p>Watch it burn. Drag to rotate, alihan is durak</p>
    <button id="reset-btn">Reset Candle</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    // --- Configuration ---
    const CONFIG = {
        meltSpeed: 0.0003,      // How fast the candle burns
        flameFlickerSpeed: 0.1, // Speed of flame animation
        waxColor: 0xfff5e1,     // Creamy white
        flameColor: 0xffaa00,   // Orange/Yellow
        bgColor: 0x111111
    };

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.bgColor);
    scene.fog = new THREE.Fog(CONFIG.bgColor, 10, 50);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 15, 25);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // --- Controls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minPolarAngle = 0;
    controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below table
    controls.target.set(0, 2, 0);

    // --- Lighting ---
    // 1. Ambient light (very dim, simulated night)
    const ambientLight = new THREE.AmbientLight(0x404060, 0.2);
    scene.add(ambientLight);

    // 2. The Flame Light (Dynamic PointLight)
    const flameLight = new THREE.PointLight(0xff6600, 1, 20);
    flameLight.castShadow = true;
    flameLight.shadow.bias = -0.001;
    scene.add(flameLight);

    // --- Objects ---

    // 1. Table/Floor
    const planeGeometry = new THREE.PlaneGeometry(100, 100);
    const planeMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x222222, 
        roughness: 0.8,
        metalness: 0.2
    });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Group to hold candle parts
    const candleGroup = new THREE.Group();
    scene.add(candleGroup);

    // 2. Candle Body (Wax)
    // We translate the geometry so the pivot point is at the bottom (y=0)
    // This makes scaling the height easier (it shrinks downwards).
    const candleHeight = 8;
    const candleRadius = 1.5;
    const candleGeo = new THREE.CylinderGeometry(candleRadius, candleRadius, candleHeight, 32);
    candleGeo.translate(0, candleHeight / 2, 0); 
    
    const waxMaterial = new THREE.MeshStandardMaterial({
        color: CONFIG.waxColor,
        roughness: 0.3,
        metalness: 0.1,
        transparent: true,
        opacity: 0.95
    });
    const candleMesh = new THREE.Mesh(candleGeo, waxMaterial);
    candleMesh.castShadow = true;
    candleMesh.receiveShadow = true;
    candleGroup.add(candleMesh);

    // 3. The Wick
    const wickHeight = 0.8;
    const wickGeo = new THREE.CylinderGeometry(0.05, 0.05, wickHeight, 8);
    const wickMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const wickMesh = new THREE.Mesh(wickGeo, wickMat);
    candleGroup.add(wickMesh);

    // 4. The Flame (Visual)
    // A simple deformed sphere to look like a teardrop
    const flameGeo = new THREE.SphereGeometry(0.3, 16, 16);
    // Scale it to look like a flame shape
    flameGeo.scale(1, 2.5, 1);
    
    const flameMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
    const flameMesh = new THREE.Mesh(flameGeo, flameMat);
    candleGroup.add(flameMesh);

    // 5. Wax Pool (The melted wax at the bottom)
    const poolGeo = new THREE.CylinderGeometry(candleRadius, candleRadius + 0.5, 0.1, 32);
    poolGeo.translate(0, 0.05, 0); // Sit just above table
    const poolMesh = new THREE.Mesh(poolGeo, waxMaterial);
    poolMesh.scale.set(1, 1, 1);
    poolMesh.visible = true;
    scene.add(poolMesh); // Add to scene, not candle group, so it stays flat on table

    // --- Animation State ---
    let isBurning = true;
    let time = 0;
    
    // Function to update the scene based on burn progress
    function updateCandle() {
        if (!isBurning) return;

        // 1. Melt the candle (Shrink Y scale)
        if (candleMesh.scale.y > 0.05) {
            candleMesh.scale.y -= CONFIG.meltSpeed;
        } else {
            // Candle finished
            candleMesh.scale.y = 0.05;
            isBurning = false;
            // Extinguish flame smoothly
            flameMesh.visible = false;
            flameLight.intensity = 0;
            return;
        }

        const currentHeight = candleHeight * candleMesh.scale.y;

        // 2. Update Wick Position (Always sits on top of candle)
        wickMesh.position.y = currentHeight + (wickHeight / 2) - 0.2; // -0.2 to embed slightly

        // 3. Update Flame Position (Sits on top of wick)
        const flameBaseY = currentHeight + wickHeight;
        flameMesh.position.y = flameBaseY;
        
        // 4. Update Light Position
        flameLight.position.set(0, flameBaseY + 0.5, 0);

        // 5. Grow the wax pool
        // As candle shrinks (scale goes 1 -> 0), pool grows (scale 1 -> 2.5)
        const meltedAmount = 1 - candleMesh.scale.y;
        const poolScale = 1 + (meltedAmount * 1.5);
        poolMesh.scale.set(poolScale, 1, poolScale);
    }

    function flickerFlame() {
        if (!isBurning) return;

        // Simple noise for flickering
        const noise = Math.sin(time * 20) * Math.cos(time * 12);
        const intensityNoise = Math.random() * 0.2;

        // Flicker Light Intensity
        flameLight.intensity = 1.2 + intensityNoise;
        
        // Flicker Light Position slightly (makes shadows dance)
        flameLight.position.x = Math.sin(time * 5) * 0.05;
        flameLight.position.z = Math.cos(time * 4) * 0.05;

        // Scale Flame Mesh (Squash and stretch)
        const s = 1 + (noise * 0.1);
        flameMesh.scale.set(s, s * 1.1, s);
        
        // Change flame color slightly
        const gComponent = 0.5 + (noise * 0.1); // Green component modulates yellow/red
        flameMesh.material.color.setRGB(1, gComponent, 0);
    }

    function animate() {
        requestAnimationFrame(animate);

        time += CONFIG.flameFlickerSpeed;

        updateCandle();
        flickerFlame();
        controls.update();

        renderer.render(scene, camera);
    }

    // --- Resize Handler ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Reset Functionality ---
    document.getElementById('reset-btn').addEventListener('click', () => {
        candleMesh.scale.y = 1;
        poolMesh.scale.set(1, 1, 1);
        isBurning = true;
        flameMesh.visible = true;
        flameLight.intensity = 1.2;
    });

    // Start
    animate();

</script>
</body>
  </html>
  
